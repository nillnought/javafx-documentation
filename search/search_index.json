{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This documentation is intended to help you through learning the basics of JavaFX for building a simple game.</p> <p>For more information about JavaFX please visit the official JavaFX website.</p>"},{"location":"#intended-users","title":"Intended Users","text":"<p>This guide is for term 2 CST students intending to use JavaFX to create their Object Oriented Programming term project. We will cover the general features that most term projects will have.</p>"},{"location":"#prerequisite-knowledge","title":"Prerequisite Knowledge","text":"<p>To follow this guide you should have:</p> <ul> <li> <p>Working knowledge of Java - at least what has been covered in your Object Oriented Programming course so far.</p> </li> <li> <p>Some knowledge of CSS style sheets - helpful to have, but not required.</p> </li> </ul>"},{"location":"#software-requirements","title":"Software Requirements","text":"<ul> <li>Java 11 or later</li> <li>IntelliJ IDEA</li> <li>A Windows device of Windows 10 or 11</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>The main topics of this documentation is as listed below:</p> <ul> <li>Setting up your JavaFX project</li> <li>Handling different types of player interactions</li> <li>Styling your project and adding pizzaz</li> </ul>"},{"location":"#formatting-typographical-conventions","title":"Formatting (Typographical Conventions)","text":"<p>Code blocks will have a title indicating what class the code is placed in.</p> <p>Addition.java<pre><code>    public class Addition {\n        private int num1;\n        private int num2;\n\n        public Addition(final int num1, final int num2){\n            this.num1 = num1;\n            this.num2 = num2;\n        }\n    }\n</code></pre> Any additions to previous code will be highlighted. Addition.java<pre><code>    public class Addition {\n        private int num1;\n        private int num2;\n\n        public Addition(final int num1, final int num2){\n            this.num1 = num1;\n            this.num2 = num2;\n        }\n\n        public int Add(){\n            return num1 + num2;\n        }\n    }\n</code></pre></p>"},{"location":"#notes-and-warning-messages-admonitions","title":"Notes and Warning Messages (Admonitions)","text":"<p>Note</p> <p>Notes provide additional information for a step.</p> <p>Success</p> <p>Success indicates what a successful result should look like.</p> <p>Warning</p> <p>Warnings contain crucial information about steps that may cause errors if done wrong.</p>"},{"location":"Glossary/","title":"Glossary","text":"Term Definition JavaFX A Java library used for building graphical user interfaces (GUIs) and creating desktop applications. It provides tools for creating interactive applications with ease. IDE (IntelliJ IDEA) Integrated Development Environment used for writing and debugging code. IntelliJ IDEA is widely used for Java development, including JavaFX applications. Plugin A software add-on that provides additional functionality to an application. For example, the JavaFX plugin in IntelliJ IDEA helps with JavaFX development. FXML An XML-based language used to define the user interface in JavaFX applications. It separates the UI design from the application logic for easier development. Controller A Java class that connects the logic of the application to the user interface elements defined in an FXML file. Scene The visual container in a JavaFX application where UI elements are displayed. Think of it as the \"canvas\" on which you design your application. Stage The primary window in a JavaFX application. A \"Stage\" contains a \"Scene\" and represents the main application window. VBox A layout container in JavaFX that arranges UI elements vertically. AnimationTimer A JavaFX class used to create a continuous loop for updating animations or handling repetitive actions. Timeline A JavaFX class used to create frame-based animations by defining a sequence of keyframes. Sprite A 2D image or graphic used in animations or games. It represents characters, objects, or other visual elements in a game. Sprite Sheet A collection of multiple images (frames) arranged in a grid or folder structure, used for creating animations by cycling through the frames. KeyFrame A point in a <code>Timeline</code> animation that defines a specific change or action (e.g., changing an image). Directional Animation Animations that change based on movement direction (e.g., walking up, down, left, or right). Velocity The speed and direction of an object\u2019s movement. In JavaFX, it\u2019s often controlled using variables like <code>velX</code> and <code>velY</code>. Keyboard Input The process of capturing user key presses to control elements in an application, such as moving a character in a game. Idle State A state where no actions or movement are happening. For example, when no movement keys are pressed, a character can display a still (idle) animation frame. Mouse Interaction Capturing user actions like mouse clicks, hovering, or dragging to interact with the application. Group A JavaFX node that acts as a container for other nodes (UI elements). It allows you to group multiple elements together for easier manipulation. <p>| Preloading             | A technique used to load resources (e.g., images) before the application starts to reduce lag and improve performance.                                                                         | | Button                 | A clickable UI element in JavaFX that triggers specific actions when clicked.                                                                                                                 |</p> <p>| Smooth Movement        | Movement that updates the position of an object in small increments to create fluid motion, often achieved using velocity-based calculations.                                                  | | Opacity                | The transparency of a UI element in JavaFX. A value of 1 means fully visible, while 0 means completely invisible.                                                                             | | Lazy Loading           | Loading resources like images only when they are needed to save memory and improve application performance.                                                                                   |</p>"},{"location":"Pizzazz/","title":"Personalizing and Adding Pizzazz to Your Project","text":""},{"location":"Pizzazz/#overview","title":"Overview","text":"<p>Welcome to the world of sprite animation in JavaFX! In this guide, we'll show you how to breathe life into your application by animating a character sprite with smooth movement and directional animations. By the end, you'll have a simple yet dynamic program to kickstart your JavaFX gaming projects.</p> <p></p>"},{"location":"Pizzazz/#understanding-sprite-animations","title":"Understanding Sprite Animations","text":"<p>Sprite animations are the heart of character movement in 2D games. In our approach, we'll use individual image frames to create fluid, lifelike character movements.</p>"},{"location":"Pizzazz/#sprite-sheet-organization","title":"Sprite Sheet Organization","text":"<p>Your sprite sheet is carefully organized into four directional folders:</p> <ul> <li><code>walk_down/</code>: Frames for downward movement</li> <li><code>walk_left/</code>: Frames for leftward movement</li> <li><code>walk_right/</code>: Frames for rightward movement</li> <li><code>walk_up/</code>: Frames for upward movement</li> </ul> <p>Each direction contains 8 sequential PNG files (1.png through 8.png) representing the animation frames.</p> <p></p>"},{"location":"Pizzazz/#creating-animated-sprites","title":"Creating Animated Sprites","text":"<p>In the <code>CharacterSprite</code> class, animated sprites are created by cycling through the frames using a <code>Timeline</code>. Here's how the program handles sprite animations:</p> CharacterSprite.java<pre><code>private void startAnimation(Direction direction) {\n    currentDirection = direction;\n\n    // Stop the previous animation if it exists\n    if (animationTimeline != null) {\n        animationTimeline.stop();\n    }\n\n    // Load frames for the direction\n    Image[] frames = loadFrames(direction);\n\n    // Create a timeline to cycle through the frames\n    animationTimeline = new Timeline();\n    for (int i = 0; i &lt; frames.length; i++) {\n        final int index = i;\n        animationTimeline.getKeyFrames().add(new KeyFrame(\n                Duration.millis(FRAME_DURATION * i),\n                event -&gt; spriteView.setImage(frames[index])\n        ));\n    }\n    animationTimeline.setCycleCount(Animation.INDEFINITE); // Loop the animation\n    animationTimeline.play();\n}\n</code></pre> <p></p> <p>Tip</p> <p>Frames are loaded dynamically based on the direction. The Timeline cycles through the frames, creating a smooth animation.</p>"},{"location":"Pizzazz/#adding-smooth-movement","title":"Adding Smooth Movement","text":"<p>Smooth movement is achieved using velocity-based updates. The program calculates the character's new position every frame using an <code>AnimationTimer</code>. Here's the key part of the code:</p> CharacterSprite.java<pre><code>new javafx.animation.AnimationTimer() {\n    @Override\n    public void handle(long now) {\n        spriteView.setX(spriteView.getX() + velX);\n        spriteView.setY(spriteView.getY() + velY);\n    }\n}.start();\n</code></pre> <p></p> <p>Tip</p> <p>velX and velY determine the character's velocity (speed and direction). When movement keys are pressed, the velocity is updated. The AnimationTimer continuously updates the sprite's position, ensuring smooth movement.</p>"},{"location":"Pizzazz/#keyboard-interactions","title":"Keyboard Interactions","text":"<p>The program uses keyboard input to control the sprite's movement and animation. Here's how the key handling is implemented:</p> CharacterSprite.java<pre><code>private void setupKeyControls(Scene scene) {\n    scene.setOnKeyPressed(event -&gt; {\n        if (pressedKeys.add(event.getCode())) { // Only handle new key presses\n            switch (event.getCode()) {\n                case W, UP -&gt; {\n                    velY = -MOVEMENT_SPEED;\n                    startAnimation(Direction.UP);\n                }\n                case S, DOWN -&gt; {\n                    velY = MOVEMENT_SPEED;\n                    startAnimation(Direction.DOWN);\n                }\n                case A, LEFT -&gt; {\n                    velX = -MOVEMENT_SPEED;\n                    startAnimation(Direction.LEFT);\n                }\n                case D, RIGHT -&gt; {\n                    velX = MOVEMENT_SPEED;\n                    startAnimation(Direction.RIGHT);\n                }\n            }\n        }\n    });\n\n    scene.setOnKeyReleased(event -&gt; {\n        pressedKeys.remove(event.getCode());\n        switch (event.getCode()) {\n            case W, UP, S, DOWN -&gt; velY = 0;\n            case A, LEFT, D, RIGHT -&gt; velX = 0;\n        }\n        if (pressedKeys.isEmpty()) { // No keys pressed, stop animation\n            setIdleSprite();\n        }\n    });\n}\n</code></pre>"},{"location":"Pizzazz/#keyboard-interactions_1","title":"Keyboard Interactions","text":"<p>Make your game interactive with keyboard-based movement:</p> CharacterSprite.java<pre><code>private void addKeyboardMovement(Scene scene, ImageView characterSprite, ImageView backgroundView) {\n    scene.setOnKeyPressed(event -&gt; {\n        switch (event.getCode()) {\n            case UP:\n                characterSprite.setTranslateY(characterSprite.getTranslateY() - 10);\n                backgroundView.setTranslateY(backgroundView.getTranslateY() + 10);\n                break;\n            // Similar cases for DOWN, LEFT, RIGHT\n        }\n    });\n}\n</code></pre> <p></p> <p>Tip</p> <p>Directional Movement: W, A, S, D or arrow keys (UP, DOWN, LEFT, RIGHT) control the sprite's movement. The direction determines which animation plays. Idle State: When no movement keys are pressed, the animation stops, and the sprite reverts to its idle frame.</p>"},{"location":"Pizzazz/#setting-idle-sprites","title":"Setting Idle Sprites","text":"<p>The <code>setIdleSprite</code> method ensures the character displays a static frame when not moving. This makes your game feel responsive and polished:</p> CharacterSprite.java<pre><code>private void setIdleSprite() {\n    if (animationTimeline != null) {\n        animationTimeline.stop();\n    }\n    String idleFramePath = \"assets/sprite/\" + currentDirection.path + \"1.png\";\n    spriteView.setImage(new Image(getClass().getResourceAsStream(idleFramePath)));\n}\n</code></pre>"},{"location":"Pizzazz/#organizing-sprite-frames","title":"Organizing Sprite Frames","text":"<p>The <code>loadFrames</code> method loads the frames for a given direction. This method ensures all the frames are loaded from the <code>assets/sprite/</code> directory:</p> CharacterSprite.java<pre><code>private Image[] loadFrames(Direction direction) {\n    Image[] frames = new Image[8]; // Assume 8 frames per direction\n    for (int i = 0; i &lt; 8; i++) {\n        String framePath = \"assets/sprite/\" + direction.path + (i + 1) + \".png\";\n        frames[i] = new Image(getClass().getResourceAsStream(framePath));\n    }\n    return frames;\n}\n</code></pre> <p></p> <p>Tip</p> <p>Each frame is loaded using the Direction enum, which maps to the correct folder path. Frames should be consistent in size to ensure smooth animation.</p>"},{"location":"Pizzazz/#best-practices-and-performance-tips","title":"Best Practices and Performance Tips","text":"<ul> <li>Preload images: Load all frames at the start of the game to prevent lag during gameplay.</li> <li>Keep frame sizes consistent: Ensure all frames are the same width and height to avoid visual glitches.</li> <li>Optimize performance: Use a smaller number of frames if your game starts to lag.</li> </ul> <p>Warning</p> <p>Be mindful of memory usage when loading multiple sprite frames. Consider image caching or lazy loading for larger sprite sheets.</p>"},{"location":"Pizzazz/#advanced-customization","title":"Advanced Customization","text":"<p>Experiment with these techniques to enhance your sprite animation:</p> <ul> <li>Add frame rate controls</li> <li>Implement diagonal movement</li> <li>Create transition animations between different movement states</li> </ul>"},{"location":"Pizzazz/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've learned how to create dynamic, animated sprites in JavaFX. Your character now comes to life with smooth, directional movements and an interactive background.</p> <p>Key achievements:</p> <ul> <li>Implemented multi-directional sprite animations</li> <li>Created a scrolling background</li> <li>Added keyboard-based character movement</li> </ul> <p>Keep exploring, have fun, and remember - great game design is all about bringing your imagination to life! \ud83c\udfae\ud83d\ude80</p>"},{"location":"Player_Interactions/","title":"Handling Player Interactions","text":""},{"location":"Player_Interactions/#overview","title":"Overview","text":"<p>This section will introduce handling player interactions like clicking a button, changing game scenes, player movement, and mouse interactions as we add functionality to our menu and game scene.</p>"},{"location":"Player_Interactions/#button-interactions","title":"Button Interactions","text":"<ol> <li>Create a new class in our <code>com.</code> folder called \"MenuController\"</li> </ol> <p> 2. Set the FXML file controller to <code>MenuContoller</code> mainMenu.fxml<pre><code>    &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.text.Text?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.javafxtutorial.javafxtutorial.MenuController\"&gt;\n   &lt;Text&gt;JavaFX Tutorial&lt;/Text&gt;\n   &lt;Button&gt;Start&lt;/Button&gt;\n   &lt;Button&gt;Exit&lt;/Button&gt;\n&lt;/VBox&gt;\n</code></pre> 3. Assign ID to text element</p> <p>In order for us to change elements in our FXML file, we need to give the element an ID. We will be changing our text element, so let's give it an ID. mainMenu.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.text.Text?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.javafxtutorial.javafxtutorial.MenuController\"&gt;\n   &lt;Text fx:id=\"tutorialText\"&gt;JavaFX Tutorial&lt;/Text&gt;\n   &lt;Button&gt;Start&lt;/Button&gt;\n   &lt;Button&gt;Exit&lt;/Button&gt;\n&lt;/VBox&gt;\n</code></pre> 4. Create method to change text contents</p> <p>Now we can go to our <code>MenuController.java</code> class and add a method to change our text: MenuController.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.fxml.FXML;\nimport javafx.scene.text.Text;\n\n\npublic class MenuController {\n   @FXML\n   private Text tutorialText;\n\n\n   @FXML\n   protected void onStartButtonClick() {\n       tutorialText.setText(\"The text changed!\");\n   }\n}\n</code></pre></p> <p>Warning</p> <p>The @FXML tag is required for any method that modifies an element in our FXML file.</p> <ol> <li>Assign <code>onAction</code> for start button</li> </ol> <p>Lastly, let's go back to our FXML file and tell our start button to use this method when we click it: mainMenu.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.text.Text?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.javafxtutorial.javafxtutorial.MenuController\"&gt;\n   &lt;Text fx:id=\"tutorialText\"&gt;JavaFX Tutorial&lt;/Text&gt;\n   &lt;Button onAction=\"#onStartButtonClick\"&gt;Start&lt;/Button&gt;\n   &lt;Button&gt;Exit&lt;/Button&gt;\n&lt;/VBox&gt;\n</code></pre> Now run the application and click the start button, you should end up seeing this: </p>"},{"location":"Player_Interactions/#loading-a-new-scene","title":"Loading A New Scene","text":"<p>Just having our text change when we click start is a bit boring, so let's change our method to load a new scene.</p> <ol> <li>Use start button to load an empty scene</li> </ol> <p>First let's give our start button an ID: mainMenu.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.text.Text?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.javafxtutorial.javafxtutorial.MenuController\"&gt;\n   &lt;Text fx:id=\"tutorialText\"&gt;JavaFX Tutorial&lt;/Text&gt;\n   &lt;Button onAction=\"#onStartButtonClick\" fx:id=\"startButton\"&gt;Start&lt;/Button&gt;\n   &lt;Button&gt;Exit&lt;/Button&gt;\n&lt;/VBox&gt;\n</code></pre> Now we will change our method so that it uses the button to change the root of our scene to a empty group: MenuController.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.fxml.FXML;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\n\n\npublic class MenuController {\n   @FXML\n   private Button startButton;\n\n\n   @FXML\n   protected void onStartButtonClick() {\n       startButton.getScene().setRoot(gameScreen());\n   }\n\n\n   private Group gameScreen() {\n       Group root = new Group();\n       return root;\n   }\n}\n</code></pre></p> <p>Note</p> <p>We gave our button an ID so that we could use it to get the scene it is in.</p> <p>Now when we start our application and click the start button we should get an empty scene. </p> <ol> <li>Replace empty scene with FXML scene</li> </ol> <p>Now let's create a FXML file for our game scene:  And let's modify our method to load this scene instead: MenuController.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\n\nimport java.io.IOException;\n\n\npublic class MenuController {\n\n\n   @FXML\n   private Button startButton;\n\n   @FXML\n   protected void onStartButtonClick() throws IOException {\n       startButton.getScene().setRoot(gameScreen().load());\n   }\n\n\n   private FXMLLoader gameScreen() {\n       return new FXMLLoader(getClass().getResource(\"game.fxml\"));\n   }\n}\n</code></pre></p> <p>Warning</p> <p>Before running the application be sure to remove this line from game.fxml, or else the application will not run. <code>fx:controller=\"com.javafxtutorial.javafxtutorial.Game\"</code></p> <ol> <li>Add exit functionality to exit button</li> </ol> <p>Lastly, lets add a method for our exit button: MenuController.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\n\n\nimport java.io.IOException;\n\n\npublic class MenuController {\n\n\n   @FXML\n   private Button startButton;\n\n\n   @FXML\n   protected void onStartButtonClick() throws IOException {\n       startButton.getScene().setRoot(gameScreen().load());\n   }\n\n\n   private FXMLLoader gameScreen() {\n       return new FXMLLoader(getClass().getResource(\"game.fxml\"));\n   }\n   @FXML\n   protected void onExitButtonClick() {\n       System.exit(0);\n   }\n}\n</code></pre> Make sure to tell our exit button to use the method as well:</p> mainMenu.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.text.Text?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n&lt;VBox xmlns:fx=\"http://javafx.com/fxml\" fx:controller=\"com.javafxtutorial.javafxtutorial.MenuController\"&gt;\n   &lt;Text fx:id=\"tutorialText\"&gt;JavaFX Tutorial&lt;/Text&gt;\n   &lt;Button onAction=\"#onStartButtonClick\" fx:id=\"startButton\"&gt;Start&lt;/Button&gt;\n   &lt;Button onAction=\"#onExitButtonClick\"&gt;Exit&lt;/Button&gt;\n&lt;/VBox&gt;\n</code></pre>"},{"location":"Player_Interactions/#player-movement","title":"Player Movement","text":"<p>Now that our menu is set up, let's work on our game scene.</p> <ol> <li>Create a class called Game.</li> </ol> <p> This is where we will handle our interaction and game logic.</p> <p>Before we start with player movement, let's set up our <code>game.fxml</code> scene. game.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.Group?&gt;\n&lt;?import javafx.scene.shape.Rectangle?&gt;\n&lt;Group xmlns=\"http://javafx.com/javafx\"\n      xmlns:fx=\"http://javafx.com/fxml\"\n      fx:controller=\"com.javafxtutorial.javafxtutorial.Game\"&gt;\n   &lt;Rectangle height=\"100\" width=\"100\" fill=\"orange\"/&gt;\n   &lt;Rectangle height=\"50\" width=\"50\" fill=\"blueviolet\" fx:id=\"player\"/&gt;\n\n\n&lt;/Group&gt;\n</code></pre> For now, our player will be represented by a blue rectangle with the id \"player\".</p> <ol> <li>Handle translating the player</li> </ol> <p>To move our player we need to translate their X and Y positions when the player presses a key.</p> <p>Let's set up 3 methods in our game class to help do this: Game.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.animation.AnimationTimer;\nimport javafx.fxml.FXML;\nimport javafx.scene.shape.Rectangle;\n\n\npublic class Game {\n\n\n   private double velX;\n   private double velY;\n\n\n   @FXML\n   private Rectangle player;\n\n\n\n\n   @FXML\n   public void movementLoop() {\n       new AnimationTimer() {\n           @Override\n           public void handle(long now) {\n               player.setTranslateX(player.getTranslateX() + velX);\n               player.setTranslateY(player.getTranslateY() + velY);\n           }\n       }.start();\n\n\n   }\n\n\n   public void setVelX(double velX) {\n       this.velX = velX;\n   }\n\n\n   public void setVelY(double velY) {\n       this.velY = velY;\n   }\n}\n</code></pre> Our two methods <code>setVelX</code> and <code>setVelY</code> are where we set the player's X and Y velocity, while our <code>movementLoop</code> method handles translating the player using that velocity.</p> <ol> <li>Starting our movement loop</li> </ol> <p>Before we can handle any keyboard inputs we need to start our <code>movementLoop</code>. To do this let's make some changes to our <code>MenuController</code> class.</p> <p>MenuController.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\n\nimport java.io.IOException;\n\npublic class MenuController {\n\n\n    @FXML\n    private Button startButton;\n\n    private static final int SPEED = 5;\n\n    @FXML\n    protected void onStartButtonClick() throws IOException {\n        FXMLLoader gameFXML = new FXMLLoader(getClass().getResource(\"game.fxml\"));\n\n        Group gameRoot = gameFXML.load();\n\n        Scene currentScene = startButton.getScene();\n\n        currentScene.setRoot(gameRoot);\n\n        Game gameController = gameFXML.getController();\n        gameController.movementLoop();\n\n\n        gameRoot.requestFocus();\n    }\n\n    private FXMLLoader gameScreen() {\n        return new FXMLLoader(getClass().getResource(\"game.fxml\"));\n    }\n    @FXML\n    protected void onExitButtonClick() {\n        System.exit(0);\n    }\n}\n</code></pre> To start, we've broken up our single line we used to change our Scene root into 4 lines.</p> <p>Doing this allows us to use our <code>game.fxml</code> file separately, which we can use to access our <code>Game</code> class using this line: <code>Game gameController = gameFXML.getController();</code> This allows us to start our <code>movementLoop</code> method we defined earlier.</p> <p>Lastly, we request focus for our game window so that any keyboard inputs will be correctly recieved by our game.</p> <ol> <li>Handling keyboard inputs</li> </ol> <p>Now that we've started our movement loop, we need to recieve keyboard input from the player so that we know when to change their position. To do this we will use <code>setOnKeyPressed</code> and <code>setOnKeyReleased</code> to ensure smooth movement. MenuController.java<pre><code>    package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.fxml.FXML;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.input.KeyCode;\n\n\nimport java.io.IOException;\n\n\npublic class MenuController {\n\n\n   @FXML\n   private Button startButton;\n\n\n   private static final int SPEED = 5;\n\n\n   @FXML\n   protected void onStartButtonClick() throws IOException {\n       FXMLLoader gameFXML = new FXMLLoader(getClass().getResource(\"game.fxml\"));\n\n\n       Group gameRoot = gameFXML.load();\n\n\n       Scene currentScene = startButton.getScene();\n\n\n       currentScene.setRoot(gameRoot);\n\n\n       Game gameController = gameFXML.getController();\n       gameController.movementLoop();\n\n\n       gameRoot.setOnKeyPressed(event -&gt; {\n           if (event.getCode() == KeyCode.W) {\n               gameController.setVelY(-SPEED);\n           }\n           if (event.getCode() == KeyCode.S) {\n               gameController.setVelY(SPEED);\n           }\n           if (event.getCode() == KeyCode.A) {\n               gameController.setVelX(-SPEED);\n           }\n           if (event.getCode() == KeyCode.D) {\n               gameController.setVelX(SPEED);\n           }\n       });\n       gameRoot.setOnKeyReleased(event -&gt; {\n           if (event.getCode() == KeyCode.W) {\n               gameController.setVelY(0);\n           }\n           if (event.getCode() == KeyCode.S) {\n               gameController.setVelY(0);\n           }\n           if (event.getCode() == KeyCode.A) {\n               gameController.setVelX(0);\n           }\n           if (event.getCode() == KeyCode.D) {\n               gameController.setVelX(0);\n           }\n       });\n\n\n       gameRoot.requestFocus();\n   }\n\n\n   private FXMLLoader gameScreen() {\n//        Group root = new Group();\n//        return root;\n       return new FXMLLoader(getClass().getResource(\"game.fxml\"));\n   }\n   @FXML\n   protected void onExitButtonClick() {\n       System.exit(0);\n   }\n}\n</code></pre> Now when you run the application and press start you will be able to use the WASD keys to move the blue square around. </p>"},{"location":"Player_Interactions/#mouse-interactions","title":"Mouse Interactions","text":"<p>The last type of player interaction we will handle is mouse interactions. For this we will use the orange rectangle we added to our scene previously.</p> <ol> <li>Assign an ID to the orange rectangle in <code>Game.fxml</code></li> </ol> <p>Game.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.Group?&gt;\n&lt;?import javafx.scene.shape.Rectangle?&gt;\n&lt;Group xmlns=\"http://javafx.com/javafx\"\n      xmlns:fx=\"http://javafx.com/fxml\"\n      fx:controller=\"com.javafxtutorial.javafxtutorial.Game\"&gt;\n   &lt;Rectangle height=\"100\" width=\"100\" fill=\"orange\" fx:id=\"orangeRectangle\"/&gt;\n   &lt;Rectangle height=\"50\" width=\"50\" fill=\"blueviolet\" fx:id=\"player\"/&gt;\n\n\n&lt;/Group&gt;\n</code></pre> 2. Create methods for mouse interactions</p> <p>We will be handling 3 different interactions with our orange rectangle in <code>Game.java</code>. Create 3 methods for this: mouseEnter, mouseExit, and click. Game.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.animation.AnimationTimer;\nimport javafx.fxml.FXML;\nimport javafx.scene.shape.Rectangle;\n\npublic class Game {\n\n\nprivate double velX;\nprivate double velY;\n\n\n @FXML\n private Rectangle orangeRectangle;\n\n@FXML\npublic void mouseEnter() {\n   orangeRectangle.setOpacity(0.5);\n}\n\n\n@FXML\npublic void mouseExit() {\n   orangeRectangle.setOpacity(1);\n}\n\n\n@FXML\npublic void click() {\n   orangeRectangle.setFill(Color.RED);\n}\n</code></pre> 3. Assign methods to the orange rectangle Lastly, we need to tell our rectangle to use these methods when we want it to. game.fxml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.Group?&gt;\n&lt;?import javafx.scene.shape.Rectangle?&gt;\n&lt;Group xmlns=\"http://javafx.com/javafx\"\n      xmlns:fx=\"http://javafx.com/fxml\"\n      fx:controller=\"com.javafxtutorial.javafxtutorial.Game\"&gt;\n   &lt;Rectangle height=\"100\" width=\"100\" fill=\"orange\" fx:id=\"orangeRectangle\"\n              onMouseClicked=\"#click\" onMouseEntered=\"#mouseEnter\" onMouseExited=\"#mouseExit\"/&gt;\n   &lt;Rectangle height=\"50\" width=\"50\" fill=\"blueviolet\" fx:id=\"player\"/&gt;\n\n\n&lt;/Group&gt;\n</code></pre></p> <p>Success</p> <p>Now when you run the application you should be able to hover over and click the orange rectangle to see the results.</p> <p></p>"},{"location":"Player_Interactions/#conclusion","title":"Conclusion","text":"<p>Well Done! You've learned how to handle different types of player interactions. We covered:</p> <ul> <li>Adding functionality to buttons</li> <li>Changing scenes</li> <li>Smooth player movement</li> <li>Simple mouse interactions</li> </ul> <p>Now it's time to move on to the last step, making this game your own with some customization!</p>"},{"location":"Setting_Up/","title":"Setting Up Your JavaFX Project","text":""},{"location":"Setting_Up/#overview","title":"Overview","text":"<p>Welcome to your JavaFX adventure! If you're new to desktop application development or just getting started with JavaFX, don't worry - we've got you covered. This comprehensive guide will walk you through every step of creating your first JavaFX project, from setting up your development environment to creating your first interactive scene.</p>"},{"location":"Setting_Up/#getting-started-preparing-your-development-environment","title":"Getting Started: Preparing Your Development Environment","text":""},{"location":"Setting_Up/#enabling-the-javafx-plugin","title":"Enabling the JavaFX Plugin","text":"<p>Let's kick things off by making sure you have the JavaFX plugin installed and ready to go:</p> <ol> <li>Open IntelliJ IDEA and navigate to the Plugins section</li> </ol> <ul> <li>Click on the \"Plugins\" tab on the left side of the window</li> </ul> <p></p> <ol> <li>In the search bar, type \"JavaFX\"</li> </ol> <ul> <li>Look for the official JavaFX plugin</li> <li>If it's not installed, click \"Install\" </li> <li>If it's already installed, make sure it's enabled by checking the box next to the plugin</li> </ul> <p></p> <p>Tip</p> <p>The JavaFX plugin provides additional support and tools that make developing JavaFX applications much smoother. It includes helpful code completion, scene builder integration, and other useful features.</p>"},{"location":"Setting_Up/#creating-your-first-javafx-project","title":"Creating Your First JavaFX Project","text":"<p>Now that the plugin is ready, let's create your project:</p> <ol> <li>Navigate back to the projects screen</li> </ol> <p></p> <ol> <li>Click on \"New Project\" from the IntelliJ IDEA welcome screen</li> </ol> <p></p> <ol> <li>On the left side, select \"JavaFX\" from the project types</li> </ol> <p></p> <ol> <li> <p>Project Configuration:</p> <ul> <li>Choose a meaningful name for your project (e.g., \"JavaFXTutorial\")</li> <li>Select a location to save your project</li> <li>(Optional but recommended) Check the \"Create Git repository\" box if you want version control </li> </ul> </li> </ol> <p>Once you're finished, click \"Next\"</p> <ol> <li>Additional Libraries</li> </ol> <p>You will be prompted to select additional libraries once you press next. For this guide we will not be using any additional libraries, so you may ignore this prompt and move ahead to creating your project.</p> <p></p> <ol> <li>Create your project</li> </ol>"},{"location":"Setting_Up/#exploring-your-project-structure","title":"Exploring Your Project Structure","text":"<p>Note</p> <p>When your project first loads, you'll see some default files like \"HelloApplication.java\" and \"HelloController.java\". These are generated examples that can be helpful for reference, but for our tutorial, we'll be creating our own files from scratch.</p> <p>Let's take a moment to understand the project layout:</p> <ol> <li> <p>Navigate to the <code>src</code> folder    - This is the root of your source code</p> </li> <li> <p>Expand the <code>java</code> folder    - This is where all your Java classes will live</p> </li> <li> <p>Look for the folder starting with \"com.\"    - This is your primary package folder    - In JavaFX projects, this typically follows the format <code>com.yourcompanyname.projectname</code> </p> </li> </ol>"},{"location":"Setting_Up/#creating-your-main-application-class","title":"Creating Your Main Application Class","text":"<ol> <li>Navigate to the <code>src/main/java folder</code> in your project structure.</li> <li>Create a new Java class (e.g., <code>Main.java</code>) in your package (e.g., <code>com.example</code>). </li> <li>Name your new class MainMenu</li> </ol> <p> 4. Make your class extend Application:</p> <p>MainMenu.java<pre><code>    package com.javafxtutorial.javafxtutorial;\n\n\n\n\n    import javafx.application.Application;\n\n\n    public class MainMenu extends Application {\n\n\n    }\n</code></pre> When we extend application we must provide an implementation of its start method.</p> <ol> <li>Override the start method:</li> </ol> MainMenu.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\n\n\nimport javafx.application.Application;\nimport javafx.stage.Stage;\n\n\npublic class MainMenu extends Application {\n\n   @Override\n   public void start(Stage stage) throws Exception {\n\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre> <p>Note</p> <p>launch(args) is a method of application, which handles all the logic for launching our application.</p>"},{"location":"Setting_Up/#understanding-the-application-structure","title":"Understanding the Application Structure","text":"<ul> <li><code>Application</code> is the base class for JavaFX applications</li> <li><code>start()</code> method is called when the application launches</li> <li><code>main()</code> method is the entry point that calls <code>launch()</code></li> </ul>"},{"location":"Setting_Up/#building-your-first-scene","title":"Building Your First Scene","text":"<p>Scenes in JavaFX are like canvases where you'll draw your user interface. Creating a scene is as simple as this: MainMenu.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\n\n\npublic class MainMenu extends Application {\n\n\n   @Override\n   public void start(Stage stage) throws Exception {\n       Scene scene = new Scene();\n   }\n}\n</code></pre> Well... not quite. We need to pass a parent node as a parameter to our scene when we create it.</p> <p>Note</p> <p>JavaFX has a certain structure that we need to make sure we follow: Stage -&gt; Scene -&gt; Parent</p> <p>To create a scene we need to pass it a <code>Parent</code> node, let's use a group. MainMenu.java<pre><code>    package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.application.Application;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\n\n\npublic class MainMenu extends Application {\n\n\n   @Override\n   public void start(Stage stage) throws Exception {\n        Group root = new Group();\n        Scene scene = new Scene(root);\n        stage.setScene(scene);\n        stage.show();\n   }\n}\n</code></pre></p> <p>Now when you run the application you should get a window like this: </p> <p>The window is a bit too big and is lacking a name so let's change that: MainMenu.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\n\n\nimport javafx.application.Application;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\n\n\npublic class MainMenu extends Application {\n    //define constants for window dimensions\n   private static final int WIDTH = 600;\n   private static final int HEIGHT = 500;\n\n\n   @Override\n   public void start(final Stage stage) throws Exception {\n       Group root = new Group();\n       Scene scene = new Scene(root, WIDTH, HEIGHT);\n       stage.setScene(scene);\n       //assign a title to the window\n       stage.setTitle(\"JavaFX Tutorial\");\n       stage.show();\n   }\n}\n</code></pre></p>"},{"location":"Setting_Up/#adding-elements","title":"Adding Elements","text":"<p>Now that we have our scene set up let's start adding elements to it. There's two ways we can add elements to our scene:</p> <ol> <li>Manually inserting elements</li> <li>By using FXML files</li> </ol> <p>To start we will add elements manually, then go over how we can translate the elements we added into a single FXML file.</p>"},{"location":"Setting_Up/#manually-inserting-elements","title":"Manually Inserting Elements","text":"<ol> <li>Make a helper method</li> </ol> <p>Adding elements manually takes a decent amount of space, so lets create a helper method called <code>makeSceneGroup</code> for this. Our helper method will return a group, which we will use for our scene's parent. MainMenu.java<pre><code>    package com.javafxtutorial.javafxtutorial;\n\n\n\n\nimport javafx.application.Application;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\n\n\npublic class MainMenu extends Application {\n   private static final int WIDTH = 600;\n   private static final int HEIGHT = 500;\n\n\n   @Override\n   public void start(final Stage stage) throws Exception {\n       Group root = new Group();\n       Scene scene = new Scene(root, WIDTH, HEIGHT);\n       stage.setScene(scene);\n       stage.setTitle(\"JavaFX Tutorial\");\n       stage.show();\n   }\n\n\n   private Group makeSceneGroup() {\n       Group sceneGroup = new Group();\n\n   }\n}\n</code></pre> 2. Adding elements</p> <p>Now that we have our scene set up, let's start by adding some basic shapes. We can create a rectangle by using this line of code: <pre><code>Rectangle rectangle = new Rectangle(80, 80);\n</code></pre></p> <p>Note</p> <p>When we create a rectangle, we need to pass the width and height to its constructor.</p> <p>Note</p> <p>We can also assign our rectangle a colour by passing <code>Color.RED</code>, where <code>RED</code> can be replaced with the colour we want.</p> <p>Let's add our rectangle to our group and return the group to finish our method. makeSceneGroup method<pre><code>private Group makeSceneGroup() {\n    Group sceneGroup  = new Group();\n    Rectangle rectangle = new Rectangle(80, 80, Color.RED);\n    sceneGroup.getChildren().add(rectangle);\n    return sceneGroup;\n}\n</code></pre> Now when you run our application you should see a red rectangle on screen. </p> <p>Let's remove the rectangle and add some other elements to make our menu. MainMenu.java<pre><code>package com.javafxtutorial.javafxtutorial;\n\n\nimport javafx.application.Application;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.VBox;\nimport javafx.scene.text.Text;\nimport javafx.stage.Stage;\n\n\npublic class MainMenu extends Application {\n   private static final int WIDTH = 600;\n   private static final int HEIGHT = 500;\n\n\n   @Override\n   public void start(final Stage stage) throws Exception {\n       Scene scene = new Scene(makeSceneGroup(), WIDTH, HEIGHT);\n       stage.setScene(scene);\n       stage.setTitle(\"JavaFX Tutorial\");\n       stage.show();\n   }\n\n\n   private Group makeSceneGroup() {\n       Group sceneGroup = new Group();\n       Text text = new Text(\"JavaFX Tutorial\");\n       Button Startbutton = new Button(\"Start\");\n       Button Exitbutton = new Button(\"Exit\");\n       VBox vbox = new VBox(20, text, Startbutton, Exitbutton);\n       sceneGroup.getChildren().add(vbox);\n       return sceneGroup;\n   }\n}\n</code></pre> We added a couple of elements: Text, Buttons, and something called a VBox.</p> <p>Note</p> <p>VBox stands for vertical box, it stores node elements vertically. VBox has a horizontal counterpart called HBox.</p> <p>When we run our application we should get something that looks like this. </p>     If we don't use a VBox to contain our elements, it would look like this: <p></p> <p>Here we used a few simple elements of JavaFX. For a deeper look into the types of elements JavaFx offers, take a look here.</p>"},{"location":"Setting_Up/#introduction-to-fxml-separating-design-from-logic","title":"Introduction to FXML: Separating Design from Logic","text":"<p>FXML allows you to design your user interface separately from your Java code. Let's take a look at how we can convert our menu into a FXML file. For a more detailed look into FXML check out the Oracle Documentation on it.</p> <ol> <li>Creating an FXML File</li> </ol> <p>Start by creating a new file called <code>MainMenu.fxml</code> in your resources folder: </p> <p> When you create your FXML file it will look like this:  From here, we can remove the <code>AnchorPane</code> tag and all the initial import statements as we won't be needing them.</p> <ol> <li>Recreating our scene</li> </ol> <p>To recreate our scene in our FXML file, insert this code: MainMenu.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n\n&lt;?import javafx.scene.layout.VBox?&gt;\n&lt;?import javafx.scene.text.Text?&gt;\n&lt;?import javafx.scene.control.Button?&gt;\n&lt;VBox&gt;\n   &lt;Text&gt;JavaFX Tutorial&lt;/Text&gt;\n   &lt;Button&gt;Start&lt;/Button&gt;\n   &lt;Button&gt;Exit&lt;/Button&gt;\n&lt;/VBox&gt;\n</code></pre> Let's walk through this step by step. First we create a VBox, using the VBox tag. Inside our VBox we add our text element and our two buttons, putting what we want the text and buttons to display in between their opening and closing tags.</p> <ol> <li>Loading FXML in Your Application</li> </ol> <p>Now to use our FXML file we need to load it in our start method.</p> MainMenu.java<pre><code> @Override\n public void start(final Stage stage) throws Exception {\n     FXMLLoader menuFXML = new FXMLLoader(getClass().getResource(\"MainMenu.fxml\"));\n     Scene scene = new Scene(menuFXML.load(), WIDTH, HEIGHT);\n     stage.setScene(scene);\n     stage.setTitle(\"JavaFX Tutorial\");\n     stage.show();\n }\n</code></pre> <p>Note</p> <p>Make sure that in our scene constructor we call our FXML loader we created with .load() attached!! Or else it will not accept it and will fail to construct our scene.</p> <p>Success</p> <p>You've successfully created the base for a menu. The final result should look like the image below.</p> <p></p>"},{"location":"Setting_Up/#conclusion","title":"Conclusion","text":"<p>Congratulations! You've just taken your first steps into the world of JavaFX application development. We've covered:</p> <ul> <li>Setting up a JavaFX project in IntelliJ IDEA</li> <li>Creating a basic application structure</li> <li>Building scenes with interactive elements</li> <li>Introducing FXML for UI design</li> <li>Remember, every great application starts with a simple first step. You've just taken that step! \ud83d\ude80</li> </ul> <p>Keep experimenting, have fun, and don't be afraid to try new things. Happy coding!</p>"},{"location":"Troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide addresses common issues you might encounter while working on your JavaFX projects. Each issue includes possible causes and solutions to help you quickly resolve them.</p>"},{"location":"Troubleshooting/#1-javafx-plugin-not-found-in-intellij-idea","title":"1. JavaFX Plugin Not Found in IntelliJ IDEA","text":"<p>Problem: The JavaFX plugin is missing or not available in IntelliJ IDEA.  </p> <p>Possible Causes: The plugin is not installed or enabled. Your IntelliJ IDEA version does not support the JavaFX plugin.  </p> <p>Solutions: Go to <code>File &gt; Settings &gt; Plugins &gt; Marketplace</code>. Search for \"JavaFX\" and click Install. If already installed, ensure it is enabled under Installed Plugins. Check that you're using IntelliJ IDEA Ultimate or Community Edition (JavaFX support may be limited in older versions).</p>"},{"location":"Troubleshooting/#2-fxml-file-fails-to-load","title":"2. FXML File Fails to Load","text":"<p>Problem: Your application crashes or shows a <code>NullPointerException</code> when trying to load an FXML file.  </p> <p>Possible Causes: The file path to the FXML file is incorrect. The <code>fx:controller</code> attribute in the FXML file is missing or points to the wrong class. Required elements in the FXML file are missing.  </p> <p>Solutions: Verify the FXML file path in your code: <pre><code>FXMLLoader loader = new FXMLLoader(getClass().getResource(\"MainMenu.fxml\"));\n</code></pre> Ensure the <code>fx:controller</code> attribute in the FXML file matches the fully qualified name of your controller class: <pre><code>fx:controller=\"com.javafxtutorial.javafxtutorial.MenuController\"\n</code></pre> Check for missing <code>fx:id</code> attributes or required fields in your FXML file.</p>"},{"location":"Troubleshooting/#3-buttons-or-other-ui-elements-do-not-respond","title":"3. Buttons or Other UI Elements Do Not Respond","text":"<p>Problem: Clicking buttons or interacting with UI elements has no effect.  </p> <p>Possible Causes: The <code>onAction</code> attribute in the FXML file is not set or is incorrect. The method in the controller is missing the <code>@FXML</code> annotation.  </p> <p>Solutions: Ensure the button's <code>onAction</code> attribute is correctly linked to a method in the controller: <pre><code>&lt;Button onAction=\"#onStartButtonClick\" text=\"Start\" /&gt;\n</code></pre> Confirm the controller method is annotated with <code>@FXML</code>: <pre><code>@FXML\nprotected void onStartButtonClick() {\n    // Your logic here\n}\n</code></pre></p>"},{"location":"Troubleshooting/#4-animation-not-working","title":"4. Animation Not Working","text":"<p>Problem: The sprite animation does not play, or the character appears frozen.  </p> <p>Possible Causes: The <code>Timeline</code> or <code>AnimationTimer</code> is not properly set up or started. The image frames for the animation are missing or not properly loaded.  </p> <p>Solutions: Make sure the <code>Timeline</code> or <code>AnimationTimer</code> is started: <pre><code>animationTimeline.play();\n</code></pre> Verify the sprite frames are in the correct directory and the file paths are valid: <pre><code>String framePath = \"assets/sprite/walk_down/1.png\";\n</code></pre> Use consistent file naming (e.g., <code>1.png, 2.png</code>) and frame dimensions for all images in the sprite sheet.</p>"},{"location":"Troubleshooting/#5-character-wont-move","title":"5. Character Won\u2019t Move","text":"<p>Problem: The character does not move when pressing the WASD or arrow keys.  </p> <p>Possible Causes: Key input events are not being captured. <code>velX</code> and <code>velY</code> values are not being updated. The <code>AnimationTimer</code> for movement is not running.  </p> <p>Solutions: Ensure that focus is set on the scene to capture key presses: <pre><code>scene.setOnKeyPressed(...);\nscene.setOnKeyReleased(...);\nscene.getRoot().requestFocus();\n</code></pre> Verify that the velocity values (<code>velX</code> and <code>velY</code>) are being updated in response to key presses. Confirm the <code>AnimationTimer</code> for movement is started: <pre><code>movementLoop.start();\n</code></pre></p>"},{"location":"Troubleshooting/#6-black-screen-or-blank-scene","title":"6. Black Screen or Blank Scene","text":"<p>Problem: The application runs, but the screen is black or empty.  </p> <p>Possible Causes: No <code>Scene</code> has been set on the <code>Stage</code>. The <code>Scene</code> root is empty or not properly initialized.  </p> <p>Solutions: Ensure you set a valid <code>Scene</code> on the <code>Stage</code>: <pre><code>stage.setScene(scene);\n</code></pre> Verify that the root element (e.g., <code>Group</code>, <code>VBox</code>) contains child elements: <pre><code>Group root = new Group();\nroot.getChildren().add(spriteView);\n</code></pre></p>"},{"location":"Troubleshooting/#7-filenotfoundexception-or-missing-assets","title":"7. FileNotFoundException or Missing Assets","text":"<p>Problem: The application crashes because an image, FXML file, or other asset cannot be found.  </p> <p>Possible Causes: The file path is incorrect or the resource is not in the expected directory. The file is not included in the project resources.  </p> <p>Solutions: Ensure the asset is located in the <code>resources</code> folder of your project and that the file path matches: <pre><code>new Image(getClass().getResourceAsStream(\"assets/sprite/walk_down/1.png\"));\n</code></pre> Check that the resource folder is marked correctly in your IDE (right-click the folder &gt; Mark as Resources Root in IntelliJ IDEA).</p>"},{"location":"Troubleshooting/#8-background-does-not-scroll","title":"8. Background Does Not Scroll","text":"<p>Problem: The background remains static when the character moves.  </p> <p>Possible Causes: The background's <code>translateX</code> or <code>translateY</code> values are not being updated.  </p> <p>Solutions: Update the background position along with the character's movement: <pre><code>backgroundView.setTranslateX(backgroundView.getTranslateX() - velX);\nbackgroundView.setTranslateY(backgroundView.getTranslateY() - velY);\n</code></pre></p>"},{"location":"Troubleshooting/#9-mouse-interaction-not-working","title":"9. Mouse Interaction Not Working","text":"<p>Problem: Hovering over or clicking elements does not produce the expected behavior.  </p> <p>Possible Causes: The <code>onMouseEntered</code>, <code>onMouseExited</code>, or <code>onMouseClicked</code> attributes are missing from the FXML file. The corresponding methods in the controller are not annotated with <code>@FXML</code>.  </p> <p>Solutions: Ensure the FXML file includes mouse interaction attributes: <pre><code>&lt;Rectangle onMouseEntered=\"#mouseEnter\" onMouseExited=\"#mouseExit\" onMouseClicked=\"#click\" /&gt;\n</code></pre> Verify the controller methods are annotated with <code>@FXML</code>: <pre><code>@FXML\npublic void mouseEnter() {\n    rectangle.setOpacity(0.5);\n}\n</code></pre></p>"},{"location":"Troubleshooting/#10-performance-issues-lag-or-stuttering","title":"10. Performance Issues (Lag or Stuttering)","text":"<p>Problem: The application lags or animations stutter during runtime.  </p> <p>Possible Causes: Too many resources (e.g., images) are being loaded during runtime. The frame rate is too high or poorly optimized.  </p> <p>Solutions: Preload resources at the start of the application: <pre><code>Image[] frames = loadFrames(Direction.DOWN);\n</code></pre> Reduce the number of animation frames or use smaller images to optimize performance. Use <code>setCycleCount(Animation.INDEFINITE)</code> for animations to avoid unnecessary overhead.</p>"},{"location":"Troubleshooting/#11-application-crashes-on-exit","title":"11. Application Crashes on Exit","text":"<p>Problem: The application does not exit properly or throws an error.  </p> <p>Possible Causes: The <code>System.exit(0)</code> method is not called for proper termination. Background threads (e.g., <code>AnimationTimer</code>) are still running.  </p> <p>Solutions: Ensure the <code>onExitButtonClick</code> method calls <code>System.exit(0)</code>: <pre><code>@FXML\nprotected void onExitButtonClick() {\n    System.exit(0);\n}\n</code></pre> Stop any running timers or threads before exiting: <pre><code>animationTimeline.stop();\n</code></pre></p> <p>If you encounter an issue not listed here, carefully review your code for typos, missing annotations, or incorrect file paths. Happy coding!</p>"}]}